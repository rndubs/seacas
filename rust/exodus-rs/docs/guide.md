# Exodus-RS User Guide

This guide provides a comprehensive introduction to using the exodus-rs library for working with Exodus II finite element data files.

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Quick Start](#quick-start)
4. [Core Concepts](#core-concepts)
5. [Reading Files](#reading-files)
6. [Writing Files](#writing-files)
7. [Variables and Time Steps](#variables-and-time-steps)
8. [Advanced Features](#advanced-features)
9. [Performance Tips](#performance-tips)
10. [Troubleshooting](#troubleshooting)

## Introduction

Exodus II is a data format designed for storing finite element analysis (FEA) meshes and results. The exodus-rs library provides a pure Rust implementation with both low-level and high-level APIs for maximum flexibility and safety.

### Features

- **Type-safe API**: Leverages Rust's type system to prevent common errors at compile time
- **Zero unsafe code**: Memory safe with no manual memory management
- **NetCDF-4/HDF5 backend**: Efficient storage with compression support
- **Builder pattern**: Ergonomic high-level API for common operations
- **Comprehensive error handling**: Clear error messages with context

## Installation

Add exodus-rs to your `Cargo.toml`:

```toml
[dependencies]
exodus-rs = "0.1"
```

### System Dependencies

Exodus-rs requires HDF5 and NetCDF C libraries:

**Ubuntu/Debian:**
```bash
sudo apt-get install libhdf5-dev libnetcdf-dev pkg-config
```

**macOS (Homebrew):**
```bash
brew install hdf5 netcdf
```

### Features

Enable optional features in your `Cargo.toml`:

```toml
[dependencies]
exodus-rs = { version = "0.1", features = ["netcdf4", "ndarray", "parallel"] }
```

Available features:
- `netcdf4` (default): NetCDF-4/HDF5 backend support
- `ndarray`: Integration with ndarray for array operations
- `parallel`: Parallel I/O support (requires parallel NetCDF)
- `serde`: Serialization support for types

## Quick Start

### Creating a Simple Mesh

```rust
use exodus_rs::*;

fn main() -> Result<(), ExodusError> {
    // Create a new file
    let mut file = ExodusFile::create_default("simple_mesh.exo")?;

    // Initialize database
    let params = InitParams {
        title: "Simple 2D Mesh".to_string(),
        num_dim: 2,
        num_nodes: 4,
        num_elems: 1,
        num_elem_blocks: 1,
        ..Default::default()
    };
    file.init(&params)?;

    // Write coordinates (square)
    let x = vec![0.0, 1.0, 1.0, 0.0];
    let y = vec![0.0, 0.0, 1.0, 1.0];
    file.put_coords(&x, Some(&y), None)?;

    // Define element block
    let block = Block {
        id: 1,
        entity_type: EntityType::ElemBlock,
        topology: "QUAD4".to_string(),
        num_entries: 1,
        num_nodes_per_entry: 4,
        num_edges_per_entry: 0,
        num_faces_per_entry: 0,
        num_attributes: 0,
    };
    file.put_block(&block)?;

    // Write connectivity
    let connectivity = vec![1, 2, 3, 4];
    file.put_connectivity(1, &connectivity)?;

    Ok(())
}
```

### Reading a Mesh

```rust
use exodus_rs::*;

fn main() -> Result<(), ExodusError> {
    // Open existing file
    let file = ExodusFile::open("simple_mesh.exo")?;

    // Read initialization parameters
    let params = file.init_params()?;
    println!("Title: {}", params.title);
    println!("Dimensions: {}", params.num_dim);
    println!("Nodes: {}", params.num_nodes);
    println!("Elements: {}", params.num_elems);

    // Read coordinates
    let coords = file.coords::<f64>()?;
    println!("First node: ({}, {})", coords.x[0], coords.y[0]);

    // Read element blocks
    let block_ids = file.elem_block_ids()?;
    for block_id in block_ids {
        let block = file.block(EntityType::ElemBlock, block_id)?;
        println!("Block {}: {} {}",
            block.id,
            block.num_entries,
            block.topology
        );

        let conn = file.connectivity(block_id)?;
        println!("Connectivity: {:?}", conn.nodes);
    }

    Ok(())
}
```

### Using the High-Level Builder API

```rust
use exodus_rs::{MeshBuilder, BlockBuilder, Topology};

fn main() -> Result<(), ExodusError> {
    // Use fluent builder API
    MeshBuilder::new("My Mesh")
        .dimensions(3)
        .coordinates(
            vec![0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0],  // x
            vec![0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0],  // y
            vec![0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0],  // z
        )
        .add_block(
            BlockBuilder::new(1, Topology::Hex8)
                .connectivity(vec![1, 2, 3, 4, 5, 6, 7, 8])
                .build()
        )
        .qa_record("MyApp", "1.0.0", "2025-11-10", "12:00:00")
        .info("Generated by exodus-rs example")
        .write("mesh.exo")?;

    Ok(())
}
```

## Core Concepts

### File Modes

Exodus-rs uses type-state pattern to enforce file mode at compile time:

```rust
// Write mode - can only write
let mut file = ExodusFile::create_default("new.exo")?;

// Read mode - can only read
let file = ExodusFile::open("existing.exo")?;

// Append mode - can read and write
let mut file = ExodusFile::append("existing.exo")?;
```

### Entity Types

Exodus II organizes data by entity types:

- **Nodal**: Data associated with nodes (coordinates, nodal variables)
- **Element Blocks**: Groups of elements with the same topology
- **Node/Side/Element Sets**: Named collections of entities
- **Edge/Face Blocks**: Higher-order geometric entities
- **Assemblies**: Hierarchical groupings
- **Blobs**: Arbitrary binary data

### Coordinates

Coordinates are stored per dimension:

```rust
// 2D mesh
file.put_coords(&x, Some(&y), None)?;

// 3D mesh
file.put_coords(&x, Some(&y), Some(&z))?;

// Reading coordinates
let coords = file.coords::<f64>()?;
for i in 0..coords.x.len() {
    let node = coords.get(i).unwrap();
    println!("Node {}: {:?}", i, node);
}
```

### Element Blocks

Element blocks group elements of the same topology:

```rust
let block = Block {
    id: 1,
    entity_type: EntityType::ElemBlock,
    topology: "HEX8".to_string(),
    num_entries: 100,          // 100 elements
    num_nodes_per_entry: 8,    // 8 nodes per hex
    num_edges_per_entry: 0,
    num_faces_per_entry: 0,
    num_attributes: 0,
};
file.put_block(&block)?;
```

Supported topologies include:
- **1D**: BAR2, BAR3
- **2D**: TRI3, TRI6, QUAD4, QUAD8, QUAD9
- **3D**: TET4, TET10, HEX8, HEX20, HEX27, WEDGE6, PYRAMID5
- **Special**: NSIDED (polygons), NFACED (polyhedra)

## Reading Files

### Opening Files

```rust
// Read-only mode
let file = ExodusFile::open("mesh.exo")?;

// Check file format and version
let format = file.format()?;
let (major, minor) = file.version()?;
println!("Format: {:?}, Version: {}.{}", format, major, minor);
```

### Reading Metadata

```rust
// Initialization parameters
let params = file.init_params()?;

// QA records (software provenance)
let qa_records = file.qa_records()?;
for qa in qa_records {
    println!("{} v{} on {} at {}",
        qa.code_name, qa.code_version, qa.date, qa.time);
}

// Information records
let info = file.info_records()?;
for line in info {
    println!("{}", line);
}
```

### Reading Mesh Data

```rust
// Get all element block IDs
let block_ids = file.elem_block_ids()?;

// Read each block
for block_id in block_ids {
    let block = file.block(EntityType::ElemBlock, block_id)?;
    let connectivity = file.connectivity(block_id)?;

    // Access connectivity data
    println!("Block {} has {} elements",
        block_id,
        connectivity.nodes.len() / block.num_nodes_per_entry
    );
}

// Read sets
let node_set_ids = file.set_ids(EntityType::NodeSet)?;
for set_id in node_set_ids {
    let set = file.set(EntityType::NodeSet, set_id)?;
    println!("Node set {} has {} nodes", set_id, set.num_entries);
}
```

## Writing Files

### Creating Files with Options

```rust
use exodus_rs::{CreateOptions, CreateMode, FileFormat, FloatSize, Int64Mode};

let options = CreateOptions {
    mode: CreateMode::Clobber,           // Overwrite if exists
    format: FileFormat::NetCDF4,          // Use NetCDF-4/HDF5
    float_size: FloatSize::Double,        // Use f64
    int64_mode: Int64Mode::All,           // Use i64 for all integers
    compression: Some(6),                  // Compression level 1-9
};

let mut file = ExodusFile::create("mesh.exo", options)?;
```

### Writing Complete Mesh

```rust
// 1. Initialize
let params = InitParams {
    title: "Complete Example".to_string(),
    num_dim: 3,
    num_nodes: 8,
    num_elems: 1,
    num_elem_blocks: 1,
    ..Default::default()
};
file.init(&params)?;

// 2. Add QA records
file.put_qa_records(&[
    QaRecord {
        code_name: "MyApp".to_string(),
        code_version: "1.0.0".to_string(),
        date: "2025-11-10".to_string(),
        time: "12:00:00".to_string(),
    }
])?;

// 3. Write coordinates
let x = vec![0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0];
let y = vec![0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0];
let z = vec![0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0];
file.put_coords(&x, Some(&y), Some(&z))?;

// 4. Define element block
let block = Block {
    id: 1,
    entity_type: EntityType::ElemBlock,
    topology: "HEX8".to_string(),
    num_entries: 1,
    num_nodes_per_entry: 8,
    num_edges_per_entry: 0,
    num_faces_per_entry: 0,
    num_attributes: 0,
};
file.put_block(&block)?;

// 5. Write connectivity
file.put_connectivity(1, &vec![1, 2, 3, 4, 5, 6, 7, 8])?;
```

### Writing Sets

```rust
// Node set
let node_set = Set {
    id: 1,
    entity_type: EntityType::NodeSet,
    num_entries: 4,
    num_dist_factors: 4,
};
file.put_set(&node_set)?;
file.put_set_params(1, EntityType::NodeSet, &[1, 2, 3, 4], Some(&[1.0, 1.0, 1.0, 1.0]))?;

// Side set (boundary conditions)
let side_set = Set {
    id: 2,
    entity_type: EntityType::SideSet,
    num_entries: 1,
    num_dist_factors: 0,
};
file.put_set(&side_set)?;
file.put_side_set(2, &[1], &[1])?;  // Element 1, side 1
```

## Variables and Time Steps

### Defining Variables

```rust
// Global variables (scalars per time step)
file.define_variables(EntityType::Global, &["total_mass", "total_energy"])?;

// Nodal variables (values per node per time step)
file.define_variables(EntityType::Nodal, &["temperature", "pressure"])?;

// Element variables (values per element per time step)
file.define_variables(EntityType::ElemBlock, &["stress_xx", "stress_yy", "stress_zz"])?;
```

### Truth Tables

Truth tables specify which variables exist on which blocks:

```rust
// Define which element variables exist on which blocks
let num_blocks = 2;
let num_vars = 3;

// Truth table: [block1_var1, block1_var2, block1_var3, block2_var1, ...]
let truth_table = vec![
    1, 1, 0,  // Block 1: has var1, var2; not var3
    1, 0, 1,  // Block 2: has var1, var3; not var2
];

file.put_truth_table(EntityType::ElemBlock, &truth_table)?;
```

### Writing Time Step Data

```rust
// Write data for each time step
for step in 0..10 {
    let time = step as f64 * 0.1;
    file.put_time(step + 1, time)?;

    // Global variables
    file.put_var(step + 1, EntityType::Global, 0, 0, &[100.0 + step as f64])?;

    // Nodal variables
    let temp: Vec<f64> = (0..num_nodes)
        .map(|i| 20.0 + i as f64 + step as f64)
        .collect();
    file.put_var(step + 1, EntityType::Nodal, 0, 0, &temp)?;

    // Element variables
    let stress: Vec<f64> = (0..num_elems)
        .map(|i| 1000.0 + i as f64 * 10.0 + step as f64)
        .collect();
    file.put_var(step + 1, EntityType::ElemBlock, 0, 1, &stress)?;
}
```

### Reading Time Step Data

```rust
// Get number of time steps
let num_steps = file.num_times()?;

// Get all time values
let times = file.times()?;
println!("Time steps: {:?}", times);

// Read variable at specific time step
let step = 5;
let temp = file.var(step, EntityType::Nodal, 0, 0)?;
println!("Temperature at step {}: {:?}", step, temp);

// Read variable names
let var_names = file.variable_names(EntityType::Nodal)?;
for (i, name) in var_names.iter().enumerate() {
    println!("Variable {}: {}", i, name);
}
```

## Advanced Features

### Assemblies

Hierarchical grouping of entities:

```rust
let assembly = Assembly {
    id: 1,
    name: "Wing".to_string(),
    entity_type: EntityType::ElemBlock,
    entity_list: vec![1, 2, 3],  // Block IDs 1, 2, 3
};
file.put_assembly(&assembly)?;

// Read assemblies
let assembly_ids = file.assembly_ids()?;
for id in assembly_ids {
    let assembly = file.assembly(id)?;
    println!("Assembly {}: {} contains {} entities",
        assembly.id,
        assembly.name,
        assembly.entity_list.len()
    );
}
```

### Blobs

Store arbitrary binary data:

```rust
let blob = Blob {
    id: 1,
    name: "mesh_metadata".to_string(),
};
let data = vec![0u8; 1024];  // Binary data
file.put_blob(&blob, &data)?;

// Read blobs
let (blob, data) = file.blob(1)?;
println!("Blob {}: {} ({} bytes)", blob.id, blob.name, data.len());
```

### Properties and Attributes

Attach metadata to entities:

```rust
// Integer properties
file.put_property(EntityType::ElemBlock, 1, "material_id", 42)?;

// Read properties
let mat_id = file.property(EntityType::ElemBlock, 1, "material_id")?;
```

### Entity Naming

Assign names to entities:

```rust
// Name blocks
file.put_name(EntityType::ElemBlock, 1, "steel_elements")?;
file.put_name(EntityType::ElemBlock, 2, "aluminum_elements")?;

// Read names
let name = file.name(EntityType::ElemBlock, 1)?;
println!("Block 1 name: {}", name);

// Get all names
let names = file.names(EntityType::ElemBlock)?;
```

### ID Maps

Map between local indices and global IDs:

```rust
// Node ID map (arbitrary global IDs)
let node_ids = vec![100, 101, 102, 103];
file.put_id_map(EntityType::Nodal, &node_ids)?;

// Read ID map
let node_map = file.id_map(EntityType::Nodal)?;
```

## Performance Tips

### Use Appropriate Float Size

Choose float precision based on your needs:

```rust
// Double precision (more accurate, larger files)
let options = CreateOptions {
    float_size: FloatSize::Double,
    ..Default::default()
};

// Single precision (faster, smaller files)
let options = CreateOptions {
    float_size: FloatSize::Float,
    ..Default::default()
};
```

### Enable Compression

Compression can significantly reduce file size:

```rust
let options = CreateOptions {
    compression: Some(6),  // Level 1-9 (6 is good balance)
    ..Default::default()
};
```

### Batch Operations

Write data in larger batches when possible:

```rust
// Less efficient: write one at a time
for step in 0..100 {
    file.put_time(step + 1, step as f64)?;
    file.put_var(step + 1, EntityType::Nodal, 0, 0, &data)?;
}

// More efficient: prepare all data first
let all_data: Vec<_> = (0..100).map(|step| {
    // Prepare data
    vec![step as f64; num_nodes]
}).collect();

for (step, data) in all_data.iter().enumerate() {
    file.put_time(step + 1, step as f64)?;
    file.put_var(step + 1, EntityType::Nodal, 0, 0, data)?;
}
```

### Use sync() When Needed

Explicitly flush data to disk:

```rust
file.sync()?;  // Ensure data is written
```

## Troubleshooting

### Common Errors

**"NetCDF library not found"**
```bash
# Ensure libraries are installed
pkg-config --modversion netcdf

# Set PKG_CONFIG_PATH if needed
export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
```

**"File not initialized"**
```rust
// Always initialize after creating
let mut file = ExodusFile::create_default("mesh.exo")?;
file.init(&params)?;  // Must call init before other operations
```

**"Invalid array length"**
```rust
// Ensure arrays match declared sizes
let params = InitParams { num_nodes: 4, .. };
file.init(&params)?;

// Must provide exactly 4 coordinates
let x = vec![0.0, 1.0, 1.0, 0.0];  // ✓ Correct
let x = vec![0.0, 1.0];              // ✗ Error: wrong length
```

**"Index exceeds dimension bound"**
```rust
// Use 1-based indexing for entity IDs in connectivity
let connectivity = vec![1, 2, 3, 4];  // ✓ Correct (1-based)
let connectivity = vec![0, 1, 2, 3];  // ✗ May cause errors
```

### Debug Tips

Enable debug output:
```rust
env RUST_LOG=exodus_rs=debug cargo run
```

Check file contents with ncdump:
```bash
ncdump -h mesh.exo  # Show header
ncdump mesh.exo     # Show all data
```

### Getting Help

- [GitHub Issues](https://github.com/sandialabs/seacas/issues)
- [SEACAS Documentation](https://sandialabs.github.io/seacas-docs/)
- [Exodus II Format Specification](https://sandialabs.github.io/seacas-docs/exodusII-new.pdf)

## Next Steps

- See [cookbook.md](cookbook.md) for common recipes
- See [migration.md](migration.md) for migrating from C API
- Check the [examples/](../examples/) directory for complete working examples
- Read the [API documentation](https://docs.rs/exodus-rs) for detailed reference
