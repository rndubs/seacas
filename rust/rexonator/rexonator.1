.TH REXONATOR 1 "November 2025" "rexonator 0.1.0" "User Commands"
.SH NAME
rexonator \- transform Exodus II mesh files with geometric operations
.PP
.nf
            __
           / _)  THE REXONATOR!!!
    .-^^^-/ /
 __/       /
<__.|_|-|_|

.fi
.SH SYNOPSIS
.B rexonator
[\fIOPTIONS\fR] \fIINPUT\fR \fIOUTPUT\fR
.SH DESCRIPTION
.B rexonator
applies geometric transformations to Exodus II finite element mesh files.
It reads an input mesh, applies a sequence of transformations, and writes
the result to a new output file. The original input file is never modified.
.PP
Transformations include translation, rotation (using Euler angles), uniform
scaling, mirroring about coordinate axes, and copy-mirror-merge for creating
full models from half-symmetry models. Multiple transformations can be chained
together and are applied in the exact order they appear on the command line.
.SH ARGUMENTS
.TP
.I INPUT
Path to the input Exodus II file (.exo). This file must exist and be a valid
Exodus II format file.
.TP
.I OUTPUT
Path for the output Exodus II file. If this file exists, it will be overwritten.
The input file is first copied to the output location, and then
transformations are applied to the copy.
.SH OPTIONS
.SS Transformation Options
.TP
.BI \-\-translate " X,Y,Z"
Translate (move) all mesh coordinates by the specified offset vector.
The offset is specified as three comma-separated floating-point values
representing the displacement in the X, Y, and Z directions respectively.
.IP
Example: \fB\-\-translate "10.0,5.0,0.0"\fR moves the mesh 10 units in X
and 5 units in Y.
.TP
.BI \-\-rotate " SEQUENCE,ANGLE1[,ANGLE2[,ANGLE3]]"
Rotate the mesh using Euler angles. The rotation is specified as a sequence
string followed by 1-3 angles in degrees, all comma-separated.
.IP
The sequence string determines both the axes of rotation and whether the
rotation is \fBextrinsic\fR (fixed frame) or \fBintrinsic\fR (body frame):
.RS
.IP \(bu 2
\fBUppercase\fR letters (X, Y, Z) specify \fBextrinsic\fR rotations,
where each rotation is performed about the original fixed coordinate axes.
.IP \(bu 2
\fBlowercase\fR letters (x, y, z) specify \fBintrinsic\fR rotations,
where each rotation is performed about the current (rotated) body axes.
.RE
.IP
The sequence can be 1-3 characters, and the number of angles must match
the sequence length.
.IP
Examples:
.RS
.IP \(bu 2
\fB\-\-rotate "Z,90"\fR \- Rotate 90 degrees about the Z axis
.IP \(bu 2
\fB\-\-rotate "XYZ,30,45,60"\fR \- Extrinsic XYZ Euler rotation
(rotate 30° about fixed X, then 45° about fixed Y, then 60° about fixed Z)
.IP \(bu 2
\fB\-\-rotate "zyx,60,45,30"\fR \- Intrinsic zyx Euler rotation
(rotate 60° about body z, then 45° about new body y, then 30° about new body x)
.RE
.TP
.BI \-\-scale\-len " FACTOR"
Scale all mesh coordinates uniformly by the specified factor. A factor
greater than 1.0 enlarges the mesh, while a factor less than 1.0 shrinks it.
.IP
Example: \fB\-\-scale\-len 0.001\fR converts mesh units from millimeters
to meters.
.TP
.BI \-\-scale\-field " NAME,FACTOR"
Scale a specific field variable by the given factor. The argument is
specified as the field name and scale factor separated by a comma.
This operation multiplies all values of the named field variable by
the scale factor.
.IP
Can be specified multiple times to scale different fields. Field names
can contain underscores and numbers (e.g., \fBvelocity_x\fR, \fBstress_11\fR).
Scale factors can use scientific notation (e.g., \fB1.5e-3\fR).
.IP
Examples:
.RS
.IP \(bu 2
\fB\-\-scale\-field "temperature,1.8"\fR \- Scale temperature values by 1.8
.IP \(bu 2
\fB\-\-scale\-field "stress,1e6"\fR \- Convert stress from MPa to Pa
.IP \(bu 2
\fB\-\-scale\-field "pressure,0.5" \-\-scale\-field "velocity_x,2.0"\fR \- Scale multiple fields
.RE
.TP
.BI \-\-mirror " AXIS"
Mirror (reflect) the mesh about the specified coordinate plane. The axis
specifies which coordinate is negated:
.RS
.IP \(bu 2
\fBx\fR \- Mirror about the YZ plane (negate X coordinates)
.IP \(bu 2
\fBy\fR \- Mirror about the XZ plane (negate Y coordinates)
.IP \(bu 2
\fBz\fR \- Mirror about the XY plane (negate Z coordinates)
.RE
.IP
The axis can be specified in upper or lower case.
.TP
.BI \-\-copy\-mirror\-merge " AXIS"
Copy, mirror, and merge the mesh about a symmetry plane to create a full
model from a half-symmetry model. This operation:
.RS
.IP \(bu 2
Copies the entire mesh and mirrors it about the specified axis
.IP \(bu 2
Merges nodes on the symmetry plane (nodes where the axis coordinate is
approximately zero)
.IP \(bu 2
Preserves element winding order in the mirrored copy
.IP \(bu 2
Creates \fB_mirror\fR variants of all node sets and side sets
.IP \(bu 2
Negates vector field components (detected by naming convention like
\fBvelocity_x\fR, \fBu\fR, etc.) on the mirrored mesh
.RE
.IP
The axis can be \fBx\fR, \fBy\fR, or \fBz\fR (case-insensitive).
.IP
Example: \fB\-\-copy\-mirror\-merge x\fR creates a full model symmetric
about the YZ plane from a half-model where x >= 0.
.IP
\fBLimitations:\fR
.RS
.IP \(bu 2
Supported topologies: HEX8, TET4, WEDGE6, PYRAMID5, QUAD4, TRI3
.RE
.TP
.BI \-\-merge\-tolerance " VALUE"
Set the tolerance for merging nodes on the symmetry plane during
\fB\-\-copy\-mirror\-merge\fR. Nodes with |coordinate| <= tolerance are
considered to be on the symmetry plane.
.IP
Default: 0.001
.IP
If no nodes are found within the tolerance, a warning is printed and
no node merging occurs.
.SS Vector Detection Options
These options control how vector field components are detected during
\fB\-\-copy\-mirror\-merge\fR. Vector components matching the mirror axis
are negated in the mirrored mesh.
.TP
.BI \-\-vector\-fields " NAMES"
Explicitly mark fields as vector components. Specify a comma-separated list
of base names (without the axis suffix). Fields matching these base names
with axis suffixes (\fB_x\fR, \fB_y\fR, \fB_z\fR, \fB_1\fR, \fB_2\fR, \fB_3\fR,
\fB_u\fR, \fB_v\fR, \fB_w\fR) will be treated as vector components.
.IP
Example: \fB\-\-vector\-fields "velocity,displacement,force"\fR will treat
\fBvelocity_x\fR, \fBvelocity_y\fR, \fBdisplacement_x\fR, etc. as vectors.
.IP
This is useful when automatic detection fails to recognize your vector fields.
.TP
.BI \-\-scalar\-fields " NAMES"
Explicitly mark specific fields as scalars (not vectors), overriding automatic
detection. Specify a comma-separated list of exact field names.
.IP
Example: \fB\-\-scalar\-fields "max_x,flux_x,index_y"\fR prevents these fields
from being negated even if they would otherwise match vector patterns.
.IP
Scalar overrides have the highest priority and will prevent negation even if
the field matches a \fB\-\-vector\-fields\fR pattern.
.TP
.B \-\-no\-auto\-vector\-detection
Disable automatic vector component detection. When set, only fields explicitly
specified with \fB\-\-vector\-fields\fR will be treated as vectors.
.IP
By default, the tool automatically detects vector components using heuristics:
.RS
.IP \(bu 2
Fields ending with \fB_x\fR, \fB_y\fR, \fB_z\fR (with underscore separator)
.IP \(bu 2
Fields ending with \fB_1\fR, \fB_2\fR, \fB_3\fR (numeric suffixes)
.IP \(bu 2
Single-letter variables \fBu\fR, \fBv\fR, \fBw\fR (exact match only)
.RE
.IP
Known scalar patterns like \fBmax_x\fR, \fBmin_y\fR, \fBindex_z\fR are
automatically excluded from detection.
.SS Time Options
.TP
.BR \-z ", " \-\-zero\-time
Normalize time values so that the first time step has a value of zero.
This subtracts the first time step value from all time steps in the file.
.IP
This is useful when combining meshes from simulations that started at
different times, or when the absolute time values are not meaningful.
.SS NetCDF5/HDF5 Performance Options
These options control HDF5 chunk caching and chunking behavior for improved
I/O performance with large mesh files.
.PP
\fBNote on applicability:\fR Cache settings (\fB\-\-cache\-size\fR,
\fB\-\-preemption\fR) are applied via HDF5 environment variables and affect
\fBall\fR file operations (reading and writing). Chunk settings
(\fB\-\-node\-chunk\fR, \fB\-\-element\-chunk\fR, \fB\-\-time\-chunk\fR) only
affect \fBnew file creation\fR, which currently only occurs during
\fB\-\-copy\-mirror\-merge\fR operations. For simple transformations (translate,
rotate, scale, mirror), the input file is copied to the output location
and then transformations are applied to the copy, preserving the original
chunk layout.
.TP
.BI \-\-cache\-size " MB"
Set the HDF5 chunk cache size in megabytes. Larger cache sizes improve I/O
performance for large files at the cost of memory usage.
.IP
Default: Auto-detected based on environment (4 MB for login nodes,
128 MB for compute nodes, 16 MB otherwise).
.IP
Example: \fB\-\-cache\-size 256\fR sets a 256 MB cache.
.TP
.BI \-\-preemption " VALUE"
Set the HDF5 cache preemption policy, a value between 0.0 and 1.0.
.RS
.IP \(bu 2
\fB0.0\fR \- Favor write performance (don't evict write-only chunks)
.IP \(bu 2
\fB0.75\fR \- Balanced (default)
.IP \(bu 2
\fB1.0\fR \- Favor read performance (aggressively evict write-only chunks)
.RE
.IP
Example: \fB\-\-preemption 0.5\fR for balanced read/write performance.
.TP
.BI \-\-node\-chunk " SIZE"
Set the number of nodes per HDF5 chunk for nodal data. This affects
how data is organized in new files for optimal I/O patterns.
Only applies to \fB\-\-copy\-mirror\-merge\fR operations.
.IP
Default: 1,000-10,000 depending on environment.
.TP
.BI \-\-element\-chunk " SIZE"
Set the number of elements per HDF5 chunk for element data.
Only applies to \fB\-\-copy\-mirror\-merge\fR operations.
.IP
Default: 1,000-10,000 depending on environment.
.TP
.BI \-\-time\-chunk " SIZE"
Set the number of time steps per HDF5 chunk.
Only applies to \fB\-\-copy\-mirror\-merge\fR operations.
.RS
.IP \(bu 2
\fB0\fR \- No time chunking (default, mesh-oriented I/O)
.IP \(bu 2
\fB1+\fR \- Chunk multiple time steps together (for time-series analysis)
.RE
.TP
.B \-\-show\-perf\-config
Print the current performance configuration and exit without processing
any files. Useful for debugging and verifying settings.
.SS General Options
.TP
.BR \-v ", " \-\-verbose
Enable verbose output. When enabled, the program prints:
.RS
.IP \(bu 2
Input and output file paths
.IP \(bu 2
Number of operations to apply
.IP \(bu 2
Performance configuration settings
.IP \(bu 2
Mesh statistics (nodes, elements, dimensions)
.IP \(bu 2
Details of each transformation as it is applied
.IP \(bu 2
Progress bars for long-running operations (reading/writing variables,
mirroring data during copy-mirror-merge)
.RE
.TP
.BR \-h ", " \-\-help
Print a help message and exit.
.TP
.BR \-V ", " \-\-version
Print version information and exit.
.SH OPERATION ORDER
.PP
\fBIMPORTANT:\fR Transformations are applied in the exact order they appear
on the command line. This order matters because geometric transformations
are not commutative \- applying them in different orders produces different
results.
.PP
For example, the following two commands produce different results:
.IP
.nf
# Translate first, then rotate
rexonator mesh.exo out1.exo \-\-translate "10,0,0" \-\-rotate "Z,90"

# Rotate first, then translate
rexonator mesh.exo out2.exo \-\-rotate "Z,90" \-\-translate "10,0,0"
.fi
.PP
In the first case, the mesh is moved 10 units in X, then rotated 90 degrees.
In the second case, the mesh is rotated first, so the subsequent translation
of 10 units in X moves the (now rotated) mesh in a different direction
relative to its original orientation.
.PP
Multiple instances of the same transformation type can be specified:
.IP
.nf
rexonator mesh.exo out.exo \-\-rotate "X,45" \-\-rotate "Y,30" \-\-rotate "Z,15"
.fi
.PP
This applies three separate rotations in sequence.
.SH EULER ANGLE CONVENTIONS
.PP
This tool follows the scipy/mathematics convention for Euler angles:
.SS Extrinsic Rotations (Uppercase: X, Y, Z)
Rotations are performed about the fixed, original coordinate axes. Each
rotation is applied with respect to the global frame, regardless of
previous rotations.
.PP
For an extrinsic XYZ sequence with angles (\fIα\fR, \fIβ\fR, \fIγ\fR):
.IP 1. 3
Rotate by \fIα\fR about the global X axis
.IP 2. 3
Rotate by \fIβ\fR about the global Y axis
.IP 3. 3
Rotate by \fIγ\fR about the global Z axis
.SS Intrinsic Rotations (Lowercase: x, y, z)
Rotations are performed about the body-fixed axes, which move with the
object. Each rotation is applied with respect to the current orientation
of the body.
.PP
For an intrinsic xyz sequence with angles (\fIα\fR, \fIβ\fR, \fIγ\fR):
.IP 1. 3
Rotate by \fIα\fR about the body x axis
.IP 2. 3
Rotate by \fIβ\fR about the (now rotated) body y axis
.IP 3. 3
Rotate by \fIγ\fR about the (now rotated) body z axis
.SS Common Euler Sequences
.TP
.B XYZ / xyz
Often used in aerospace (roll-pitch-yaw)
.TP
.B ZYX / zyx
Common in robotics and some CAD systems
.TP
.B ZXZ / zxz
Classical Euler angles, used in physics
.SH EXAMPLES
.TP
\fBBasic translation:\fR
.nf
rexonator input.exo output.exo \-\-translate "100,50,0"
.fi
.TP
\fBScale from inches to meters:\fR
.nf
rexonator input.exo output.exo \-\-scale\-len 0.0254
.fi
.TP
\fBScale field variables:\fR
.nf
rexonator input.exo output.exo \\
    \-\-scale\-field "temperature,1.8" \\
    \-\-scale\-field "pressure,1e6"
.fi
.IP
This scales the temperature field by 1.8 (e.g., Celsius to approximate
Fahrenheit conversion) and pressure by 1e6 (e.g., MPa to Pa).
.TP
\fBRotate 90 degrees about Z axis:\fR
.nf
rexonator input.exo output.exo \-\-rotate "Z,90"
.fi
.TP
\fBComplex transformation chain:\fR
.nf
rexonator input.exo output.exo \\
    \-\-translate "0,0,\-5" \\
    \-\-rotate "XYZ,0,0,45" \\
    \-\-scale\-len 1000 \\
    \-\-translate "100,100,0" \\
    \-v
.fi
.IP
This centers the mesh at Z=0, rotates 45° about Z, scales up by 1000x,
then moves to position (100, 100, 0), with verbose output.
.TP
\fBMirror and normalize time:\fR
.nf
rexonator simulation.exo mirrored.exo \-\-mirror x \-\-zero\-time
.fi
.TP
\fBCreate full model from half-symmetry model:\fR
.nf
rexonator half_model.exo full_model.exo \-\-copy\-mirror\-merge x \-v
.fi
.IP
This mirrors the mesh about the YZ plane (x=0), merging nodes on the
symmetry plane and creating a full symmetric model.
.TP
\fBCopy-mirror-merge with custom tolerance:\fR
.nf
rexonator half.exo full.exo \\
    \-\-copy\-mirror\-merge y \\
    \-\-merge\-tolerance 0.01
.fi
.IP
Use a larger tolerance (0.01) to merge nodes that may not be exactly on
the symmetry plane due to mesh generation tolerances.
.TP
\fBCopy-mirror-merge with explicit vector fields:\fR
.nf
rexonator half.exo full.exo \\
    \-\-copy\-mirror\-merge x \\
    \-\-vector\-fields "flux,custom_vector" \\
    \-\-scalar\-fields "max_x,boundary_x" \\
    \-v
.fi
.IP
Explicitly specify which fields are vectors (flux_x, flux_y, etc. and
custom_vector_x, etc.) and which should be treated as scalars despite
having "_x" suffix.
.TP
\fBCopy-mirror-merge with no automatic detection:\fR
.nf
rexonator half.exo full.exo \\
    \-\-copy\-mirror\-merge x \\
    \-\-no\-auto\-vector\-detection \\
    \-\-vector\-fields "velocity,displacement"
.fi
.IP
Disable automatic vector detection and only negate the explicitly
specified velocity and displacement vector components.
.TP
\fBIntrinsic vs extrinsic rotation comparison:\fR
.nf
# Extrinsic: rotations about fixed global axes
rexonator mesh.exo ext.exo \-\-rotate "XYZ,30,45,60"

# Intrinsic: rotations about moving body axes
rexonator mesh.exo int.exo \-\-rotate "xyz,30,45,60"
.fi
.TP
\fBHigh-performance transformation for large files:\fR
.nf
rexonator large_mesh.exo output.exo \\
    \-\-cache\-size 256 \\
    \-\-preemption 0.5 \\
    \-\-node\-chunk 20000 \\
    \-\-translate "100,0,0" \\
    \-v
.fi
.IP
This uses a 256 MB cache with balanced preemption for optimal I/O when
processing large mesh files.
.TP
\fBCheck performance configuration:\fR
.nf
rexonator dummy.exo dummy.exo \-\-show\-perf\-config
.fi
.SH EXIT STATUS
.TP
.B 0
Success
.TP
.B 1
Error (invalid arguments, file not found, transformation failed, etc.)
.SH FILES
.TP
.I INPUT
Must be a valid Exodus II format file (NetCDF-based).
.TP
.I OUTPUT
Will be created as a copy of INPUT with transformations applied.
.SH SEE ALSO
.BR exodus (7),
.BR ncdump (1),
.BR ncview (1)
.PP
Exodus II documentation: https://sandialabs.github.io/seacas-docs/
.SH NOTES
.PP
The input file is copied to the output location before any transformations
are applied. This ensures the original file is never modified and preserves
all mesh data (connectivity, variables, sets, etc.) that is not affected
by coordinate transformations.
.PP
Time normalization (\fB\-\-zero\-time\fR) only works on files that already
contain time step data. It will report "No time steps to normalize" for
mesh-only files without time history.
.SH BUGS
Report bugs at: https://github.com/sandialabs/seacas/issues
.SH AUTHORS
Generated using exodus-rs, a Rust implementation of the Exodus II library.
.SH COPYRIGHT
BSD-3-Clause License. See the LICENSE file for details.
