/*
 * C Verification Program for Rust-Generated Exodus Files
 *
 * This program reads Exodus II files generated by the Rust exodus-rs library
 * and verifies that they can be correctly read using the C libexodus library.
 *
 * Usage: ./verify <exodus_file>
 * Returns: 0 on success, 1 on failure
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "exodusII.h"

#define MAX_STR_LENGTH 256
#define FLOAT_TOLERANCE 1e-6

/* Color codes for output */
#define COLOR_RESET   "\033[0m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_RED     "\033[31m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"

/* Test result tracking */
typedef struct {
    int total_tests;
    int passed_tests;
    int failed_tests;
} TestResults;

static TestResults results = {0, 0, 0};

/* Helper macros */
#define TEST(name) \
    do { \
        results.total_tests++; \
        printf(COLOR_BLUE "[TEST]" COLOR_RESET " %s... ", name);

#define PASS() \
        printf(COLOR_GREEN "PASS" COLOR_RESET "\n"); \
        results.passed_tests++; \
    } while(0)

#define FAIL(msg) \
        printf(COLOR_RED "FAIL" COLOR_RESET ": %s\n", msg); \
        results.failed_tests++; \
    } while(0)

/* Floating point comparison */
int float_equals(double a, double b, double tolerance) {
    return fabs(a - b) < tolerance;
}

/* Verify file can be opened and read basic metadata */
int verify_basic_read(const char *filename) {
    int exoid, error;
    float version;
    int cpu_word_size = 0;
    int io_word_size = 0;

    TEST("Open Exodus file");
    exoid = ex_open(filename, EX_READ, &cpu_word_size, &io_word_size, &version);
    if (exoid < 0) {
        FAIL("Could not open file");
        return -1;
    }
    PASS();

    printf("  File version: %.2f\n", version);
    printf("  CPU word size: %d\n", cpu_word_size);
    printf("  I/O word size: %d\n", io_word_size);

    return exoid;
}

/* Verify initialization parameters */
void verify_init_params(int exoid) {
    char title[MAX_LINE_LENGTH + 1];
    int num_dim, num_nodes, num_elem, num_elem_blk;
    int num_node_sets, num_side_sets;
    int error;

    TEST("Read initialization parameters");
    error = ex_get_init(exoid, title, &num_dim, &num_nodes, &num_elem,
                        &num_elem_blk, &num_node_sets, &num_side_sets);
    if (error < 0) {
        FAIL("Could not read init parameters");
        return;
    }
    PASS();

    printf("  Title: '%s'\n", title);
    printf("  Dimensions: %d\n", num_dim);
    printf("  Nodes: %d\n", num_nodes);
    printf("  Elements: %d\n", num_elem);
    printf("  Element blocks: %d\n", num_elem_blk);
    printf("  Node sets: %d\n", num_node_sets);
    printf("  Side sets: %d\n", num_side_sets);

    /* Verify title contains expected text */
    TEST("Verify title contains 'Rust'");
    if (strstr(title, "Rust") != NULL) {
        PASS();
    } else {
        FAIL("Title does not contain 'Rust'");
    }
}

/* Verify coordinates */
void verify_coordinates(int exoid, int num_dim, int num_nodes) {
    float *x, *y, *z;
    int error;

    TEST("Read coordinates");

    x = (float *)malloc(num_nodes * sizeof(float));
    y = (num_dim >= 2) ? (float *)malloc(num_nodes * sizeof(float)) : NULL;
    z = (num_dim >= 3) ? (float *)malloc(num_nodes * sizeof(float)) : NULL;

    error = ex_get_coord(exoid, x, y, z);
    if (error < 0) {
        FAIL("Could not read coordinates");
        free(x);
        if (y) free(y);
        if (z) free(z);
        return;
    }
    PASS();

    printf("  First node: (%.2f", x[0]);
    if (y) printf(", %.2f", y[0]);
    if (z) printf(", %.2f", z[0]);
    printf(")\n");

    free(x);
    if (y) free(y);
    if (z) free(z);
}

/* Verify element blocks */
void verify_element_blocks(int exoid, int num_elem_blk) {
    int *block_ids;
    int error, i;

    TEST("Read element block IDs");

    block_ids = (int *)malloc(num_elem_blk * sizeof(int));
    error = ex_get_ids(exoid, EX_ELEM_BLOCK, block_ids);
    if (error < 0) {
        FAIL("Could not read block IDs");
        free(block_ids);
        return;
    }
    PASS();

    printf("  Block IDs: ");
    for (i = 0; i < num_elem_blk; i++) {
        printf("%d ", block_ids[i]);
    }
    printf("\n");

    /* Verify each block */
    for (i = 0; i < num_elem_blk; i++) {
        char elem_type[MAX_STR_LENGTH];
        int num_elem_in_block, num_nodes_per_elem;
        int num_edges_per_elem, num_faces_per_elem, num_attr;

        error = ex_get_block(exoid, EX_ELEM_BLOCK, block_ids[i],
                            elem_type, &num_elem_in_block,
                            &num_nodes_per_elem, &num_edges_per_elem,
                            &num_faces_per_elem, &num_attr);

        if (error >= 0) {
            printf("  Block %d: %s, %d elements, %d nodes/elem\n",
                   block_ids[i], elem_type, num_elem_in_block, num_nodes_per_elem);
        }
    }

    free(block_ids);
}

/* Verify node sets */
void verify_node_sets(int exoid, int num_node_sets) {
    int *set_ids;
    int error, i;

    if (num_node_sets == 0) return;

    TEST("Read node set IDs");

    set_ids = (int *)malloc(num_node_sets * sizeof(int));
    error = ex_get_ids(exoid, EX_NODE_SET, set_ids);
    if (error < 0) {
        FAIL("Could not read node set IDs");
        free(set_ids);
        return;
    }
    PASS();

    printf("  Node set IDs: ");
    for (i = 0; i < num_node_sets; i++) {
        printf("%d ", set_ids[i]);
    }
    printf("\n");

    free(set_ids);
}

/* Verify side sets */
void verify_side_sets(int exoid, int num_side_sets) {
    int *set_ids;
    int error, i;

    if (num_side_sets == 0) return;

    TEST("Read side set IDs");

    set_ids = (int *)malloc(num_side_sets * sizeof(int));
    error = ex_get_ids(exoid, EX_SIDE_SET, set_ids);
    if (error < 0) {
        FAIL("Could not read side set IDs");
        free(set_ids);
        return;
    }
    PASS();

    printf("  Side set IDs: ");
    for (i = 0; i < num_side_sets; i++) {
        printf("%d ", set_ids[i]);
    }
    printf("\n");

    free(set_ids);
}

/* Verify variables */
void verify_variables(int exoid) {
    int num_glo_vars = 0, num_nod_vars = 0, num_ele_vars = 0;
    int error;

    /* Global variables */
    error = ex_get_variable_param(exoid, EX_GLOBAL, &num_glo_vars);
    if (error >= 0 && num_glo_vars > 0) {
        TEST("Read global variables");
        printf("  Global variables: %d\n", num_glo_vars);
        PASS();
    }

    /* Nodal variables */
    error = ex_get_variable_param(exoid, EX_NODAL, &num_nod_vars);
    if (error >= 0 && num_nod_vars > 0) {
        TEST("Read nodal variables");
        printf("  Nodal variables: %d\n", num_nod_vars);
        PASS();
    }

    /* Element variables */
    error = ex_get_variable_param(exoid, EX_ELEM_BLOCK, &num_ele_vars);
    if (error >= 0 && num_ele_vars > 0) {
        TEST("Read element variables");
        printf("  Element variables: %d\n", num_ele_vars);
        PASS();
    }
}

/* Verify time steps */
void verify_time_steps(int exoid) {
    int num_time_steps = 0;
    int error;
    float fdum;

    error = ex_inquire(exoid, EX_INQ_TIME, &num_time_steps, &fdum, NULL);
    if (error >= 0 && num_time_steps > 0) {
        TEST("Read time steps");
        printf("  Time steps: %d\n", num_time_steps);

        /* Read first and last time value */
        float *time_vals = (float *)malloc(num_time_steps * sizeof(float));
        error = ex_get_all_times(exoid, time_vals);
        if (error >= 0) {
            printf("  First time: %.6f\n", time_vals[0]);
            printf("  Last time: %.6f\n", time_vals[num_time_steps - 1]);
            PASS();
        } else {
            FAIL("Could not read time values");
        }
        free(time_vals);
    }
}

/* Main verification function */
int main(int argc, char *argv[]) {
    int exoid;
    char title[MAX_LINE_LENGTH + 1];
    int num_dim, num_nodes, num_elem, num_elem_blk;
    int num_node_sets, num_side_sets;
    int error;

    printf("\n");
    printf("====================================\n");
    printf("  Exodus C Verification Program\n");
    printf("====================================\n\n");

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <exodus_file>\n", argv[0]);
        return 1;
    }

    const char *filename = argv[1];
    printf("Verifying file: %s\n\n", filename);

    /* Basic file read */
    exoid = verify_basic_read(filename);
    if (exoid < 0) {
        printf("\n" COLOR_RED "FATAL: Could not open file" COLOR_RESET "\n");
        return 1;
    }

    /* Get init params for subsequent tests */
    error = ex_get_init(exoid, title, &num_dim, &num_nodes, &num_elem,
                        &num_elem_blk, &num_node_sets, &num_side_sets);
    if (error < 0) {
        printf("\n" COLOR_RED "FATAL: Could not read init parameters" COLOR_RESET "\n");
        ex_close(exoid);
        return 1;
    }

    printf("\n");

    /* Run all verification tests */
    verify_init_params(exoid);
    printf("\n");

    verify_coordinates(exoid, num_dim, num_nodes);
    printf("\n");

    verify_element_blocks(exoid, num_elem_blk);
    printf("\n");

    verify_node_sets(exoid, num_node_sets);
    verify_side_sets(exoid, num_side_sets);
    printf("\n");

    verify_variables(exoid);
    verify_time_steps(exoid);

    /* Close file */
    TEST("Close file");
    error = ex_close(exoid);
    if (error < 0) {
        FAIL("Could not close file");
    } else {
        PASS();
    }

    /* Print summary */
    printf("\n");
    printf("====================================\n");
    printf("  Test Summary\n");
    printf("====================================\n");
    printf("  Total tests:  %d\n", results.total_tests);
    printf("  " COLOR_GREEN "Passed:       %d" COLOR_RESET "\n", results.passed_tests);
    printf("  " COLOR_RED "Failed:       %d" COLOR_RESET "\n", results.failed_tests);
    printf("====================================\n\n");

    if (results.failed_tests == 0) {
        printf(COLOR_GREEN "✓ All tests passed!" COLOR_RESET "\n\n");
        return 0;
    } else {
        printf(COLOR_RED "✗ Some tests failed" COLOR_RESET "\n\n");
        return 1;
    }
}
