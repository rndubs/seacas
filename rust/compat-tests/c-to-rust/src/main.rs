//! Rust Verifier for C-Generated Exodus Files
//!
//! This program reads Exodus II files generated by the C libexodus library
//! and verifies that they can be correctly read using the Rust exodus-rs library.

use anyhow::{Context, Result};
use clap::Parser;
use exodus_rs::{mode, EntityType, ExodusFile};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "exodus-rust-verifier")]
#[command(about = "Verify C-generated Exodus files can be read by Rust")]
struct Cli {
    /// Exodus file to verify
    file: PathBuf,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

struct TestResults {
    total: usize,
    passed: usize,
    failed: usize,
}

impl TestResults {
    fn new() -> Self {
        Self {
            total: 0,
            passed: 0,
            failed: 0,
        }
    }

    fn test(&mut self, name: &str, result: Result<()>) {
        self.total += 1;
        print!("\x1b[34m[TEST]\x1b[0m {}... ", name);

        match result {
            Ok(_) => {
                println!("\x1b[32mPASS\x1b[0m");
                self.passed += 1;
            }
            Err(e) => {
                println!("\x1b[31mFAIL\x1b[0m: {}", e);
                self.failed += 1;
            }
        }
    }

    fn print_summary(&self) {
        println!("\n====================================");
        println!("  Test Summary");
        println!("====================================");
        println!("  Total tests:  {}", self.total);
        println!("  \x1b[32mPassed:       {}\x1b[0m", self.passed);
        println!("  \x1b[31mFailed:       {}\x1b[0m", self.failed);
        println!("====================================\n");

        if self.failed == 0 {
            println!("\x1b[32m✓ All tests passed!\x1b[0m\n");
        } else {
            println!("\x1b[31m✗ Some tests failed\x1b[0m\n");
        }
    }
}

fn verify_file(path: &PathBuf, verbose: bool) -> Result<bool> {
    let mut results = TestResults::new();

    println!("\n====================================");
    println!("  Exodus Rust Verification");
    println!("====================================\n");
    println!("Verifying file: {}\n", path.display());

    // Test: Open file
    let file = ExodusFile::<mode::Read>::open(path).context("Failed to open file");

    results.test(
        "Open Exodus file",
        file.as_ref()
            .map(|_| ())
            .map_err(|e| anyhow::anyhow!("{}", e)),
    );

    if file.is_err() {
        println!("\n\x1b[31mFATAL: Could not open file\x1b[0m\n");
        return Ok(false);
    }

    let file = file.unwrap();

    // Test: Read initialization parameters
    let init_result = file.init_params().context("Failed to read init parameters");
    results.test(
        "Read initialization parameters",
        init_result
            .as_ref()
            .map(|_| ())
            .map_err(|e| anyhow::anyhow!("{}", e)),
    );

    if let Ok(params) = &init_result {
        if verbose {
            println!("  Title: '{}'", params.title);
            println!("  Dimensions: {}", params.num_dim);
            println!("  Nodes: {}", params.num_nodes);
            println!("  Elements: {}", params.num_elems);
            println!("  Element blocks: {}", params.num_elem_blocks);
            println!("  Node sets: {}", params.num_node_sets);
            println!("  Side sets: {}", params.num_side_sets);
        }

        // Test: Verify title is non-empty and contains expected text
        let title_check = if params.title.is_empty() {
            Err(anyhow::anyhow!("Title is empty"))
        } else if params.title.contains("compatibility")
            || params.title.contains("C-generated")
            || params.title.contains("Rust-generated")
        {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Title does not contain expected text"))
        };
        results.test("Verify title is valid", title_check);

        println!();

        // Test: Read coordinates
        let coord_result = file.coords::<f64>().context("Failed to read coordinates");
        results.test(
            "Read coordinates",
            coord_result
                .as_ref()
                .map(|_| ())
                .map_err(|e| anyhow::anyhow!("{}", e)),
        );

        if let Ok(coords) = &coord_result {
            if verbose && !coords.x.is_empty() {
                print!("  First node: ({:.2}", coords.x[0]);
                if coords.num_dim >= 2 && !coords.y.is_empty() {
                    print!(", {:.2}", coords.y[0]);
                }
                if coords.num_dim >= 3 && !coords.z.is_empty() {
                    print!(", {:.2}", coords.z[0]);
                }
                println!(")");
            }
        }

        println!();

        // Test: Read element blocks
        if params.num_elem_blocks > 0 {
            let blocks_result = file
                .block_ids(EntityType::ElemBlock)
                .context("Failed to read block IDs");
            results.test(
                "Read element block IDs",
                blocks_result
                    .as_ref()
                    .map(|_| ())
                    .map_err(|e| anyhow::anyhow!("{}", e)),
            );

            if let Ok(block_ids) = &blocks_result {
                if verbose {
                    println!("  Block IDs: {:?}", block_ids);

                    for &block_id in block_ids {
                        if let Ok(block) = file.block(block_id) {
                            println!(
                                "  Block {}: {:?}, {} elements",
                                block_id, block.topology, block.num_entries
                            );
                        }
                    }
                }
            }

            println!();
        }

        // Test: Check for variables
        if let Ok(var_names) = file.variable_names(EntityType::Global) {
            if !var_names.is_empty() {
                results.test("Read global variables", Ok(()));
                if verbose {
                    println!("  Global variables: {}", var_names.len());
                }
            }
        }

        if let Ok(var_names) = file.variable_names(EntityType::Nodal) {
            if !var_names.is_empty() {
                results.test("Read nodal variables", Ok(()));
                if verbose {
                    println!("  Nodal variables: {}", var_names.len());
                }
            }
        }

        // Test: Check for time steps
        if let Ok(count) = file.num_time_steps() {
            if count > 0 {
                results.test("Read time steps", Ok(()));
                if verbose {
                    println!("  Time steps: {}", count);

                    if let Ok(times) = file.times() {
                        println!("  First time: {:.6}", times[0]);
                        println!("  Last time: {:.6}", times[times.len() - 1]);
                    }
                }
            }
        }
    }

    println!();
    results.print_summary();

    Ok(results.failed == 0)
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let success = verify_file(&cli.file, cli.verbose)?;

    if success {
        std::process::exit(0);
    } else {
        std::process::exit(1);
    }
}
