//! Rust Verifier for C-Generated Exodus Files
//!
//! This program reads Exodus II files generated by the C libexodus library
//! and verifies that they can be correctly read using the Rust exodus-rs library.

use anyhow::{Context, Result};
use clap::Parser;
use exodus_rs::{EntityType, ExodusFile, mode};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "exodus-rust-verifier")]
#[command(about = "Verify C-generated Exodus files can be read by Rust")]
struct Cli {
    /// Exodus file to verify
    file: PathBuf,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

struct TestResults {
    total: usize,
    passed: usize,
    failed: usize,
}

impl TestResults {
    fn new() -> Self {
        Self {
            total: 0,
            passed: 0,
            failed: 0,
        }
    }

    fn test(&mut self, name: &str, result: Result<()>) {
        self.total += 1;
        print!("\x1b[34m[TEST]\x1b[0m {}... ", name);

        match result {
            Ok(_) => {
                println!("\x1b[32mPASS\x1b[0m");
                self.passed += 1;
            }
            Err(e) => {
                println!("\x1b[31mFAIL\x1b[0m: {}", e);
                self.failed += 1;
            }
        }
    }

    fn print_summary(&self) {
        println!("\n====================================");
        println!("  Test Summary");
        println!("====================================");
        println!("  Total tests:  {}", self.total);
        println!("  \x1b[32mPassed:       {}\x1b[0m", self.passed);
        println!("  \x1b[31mFailed:       {}\x1b[0m", self.failed);
        println!("====================================\n");

        if self.failed == 0 {
            println!("\x1b[32m✓ All tests passed!\x1b[0m\n");
        } else {
            println!("\x1b[31m✗ Some tests failed\x1b[0m\n");
        }
    }
}

fn verify_file(path: &PathBuf, verbose: bool) -> Result<bool> {
    let mut results = TestResults::new();

    println!("\n====================================");
    println!("  Exodus Rust Verification");
    println!("====================================\n");
    println!("Verifying file: {}\n", path.display());

    // Test: Open file
    let file = ExodusFile::<mode::Read>::open(path)
        .context("Failed to open file");

    results.test("Open Exodus file", file.as_ref().map(|_| ()).map_err(|e| anyhow::anyhow!("{}", e)));

    if file.is_err() {
        println!("\n\x1b[31mFATAL: Could not open file\x1b[0m\n");
        return Ok(false);
    }

    let file = file.unwrap();

    // Test: Read initialization parameters
    let init_result = file.get_init().context("Failed to read init parameters");
    results.test("Read initialization parameters", init_result.as_ref().map(|_| ()).map_err(|e| anyhow::anyhow!("{}", e)));

    if let Ok(params) = &init_result {
        if verbose {
            println!("  Title: '{}'", params.title);
            println!("  Dimensions: {}", params.num_dim);
            println!("  Nodes: {}", params.num_nodes);
            println!("  Elements: {}", params.num_elem);
            println!("  Element blocks: {}", params.num_elem_blk);
            println!("  Node sets: {}", params.num_node_sets);
            println!("  Side sets: {}", params.num_side_sets);
        }

        // Test: Verify title contains expected text
        let title_check = if params.title.contains("C-generated") {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Title does not contain 'C-generated'"))
        };
        results.test("Verify title contains 'C-generated'", title_check);

        println!();

        // Test: Read coordinates
        let coord_result = file.get_coords::<f64>().context("Failed to read coordinates");
        results.test("Read coordinates", coord_result.as_ref().map(|_| ()).map_err(|e| anyhow::anyhow!("{}", e)));

        if let Ok((x, y, z)) = &coord_result {
            if verbose && !x.is_empty() {
                print!("  First node: ({:.2}", x[0]);
                if !y.is_empty() {
                    print!(", {:.2}", y[0]);
                }
                if !z.is_empty() {
                    print!(", {:.2}", z[0]);
                }
                println!(")");
            }
        }

        println!();

        // Test: Read element blocks
        if params.num_elem_blk > 0 {
            let blocks_result = file.get_block_ids().context("Failed to read block IDs");
            results.test("Read element block IDs", blocks_result.as_ref().map(|_| ()).map_err(|e| anyhow::anyhow!("{}", e)));

            if let Ok(block_ids) = &blocks_result {
                if verbose {
                    println!("  Block IDs: {:?}", block_ids);

                    for &block_id in block_ids {
                        if let Ok(block) = file.get_block(block_id) {
                            println!("  Block {}: {:?}, {} elements",
                                     block_id, block.topology, block.num_entries);
                        }
                    }
                }
            }

            println!();
        }

        // Test: Check for variables
        match file.get_variable_count(EntityType::Global) {
            Ok(count) if count > 0 => {
                results.test("Read global variables", Ok(()));
                if verbose {
                    println!("  Global variables: {}", count);
                }
            }
            _ => {}
        }

        match file.get_variable_count(EntityType::Node) {
            Ok(count) if count > 0 => {
                results.test("Read nodal variables", Ok(()));
                if verbose {
                    println!("  Nodal variables: {}", count);
                }
            }
            _ => {}
        }

        // Test: Check for time steps
        match file.get_time_step_count() {
            Ok(count) if count > 0 => {
                results.test("Read time steps", Ok(()));
                if verbose {
                    println!("  Time steps: {}", count);

                    if let Ok(times) = file.get_all_times::<f64>() {
                        println!("  First time: {:.6}", times[0]);
                        println!("  Last time: {:.6}", times[times.len() - 1]);
                    }
                }
            }
            _ => {}
        }
    }

    println!();
    results.print_summary();

    Ok(results.failed == 0)
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let success = verify_file(&cli.file, cli.verbose)?;

    if success {
        std::process::exit(0);
    } else {
        std::process::exit(1);
    }
}
